---
title: "Steve Walsh HW7"
output: html_notebook
---


```{r}
library(ggplot2)
library(ggExtra)
library(MASS)
library(rvest)
library(kableExtra)
library(foreach)
library(doParallel)
library(parallel)
library(doRNG)
#library(doSNOW)
```

```{r problem2}
set.seed(12345)
y <- rnorm(n = 1e3, mean = 1, sd = 1)

avg <- mean(y)
sum_sq <- vector()

system.time({
    for(i in 1:length(y)){
        sum_sq[i]<-(y[i]-avg)^2
        }
    sum1 <- sum(sum_sq)
})


system.time({
  sum2<-sum((y-avg)^2)
})

#When length(y)=1e7, Timing stopped at: 8593 420.8 9602
system.time({
    #cl <- makeCluster(3)
    cl <- makePSOCKcluster(rep("localhost",3))
    registerDoParallel(cl)
    sum3 <- foreach(i = 1:length(y), .combine='+') %dopar% {
        sum((y[i]-avg)^2)
    }
stopCluster(cl)
})
   
 
    # registerDoParallel(cores=6)
    # system.time({
    # tans <- foreach(b = 1:B, .combine='c') %dopar% {
    #     sum((y-avg)^2)
    # }
    # })
    # stopImplicitCluster()
    #stopCluster(cl)
# })  

#system.time({
    
#})    
```

```{r problem3}

     set.seed(1256)
     theta <- as.matrix(c(1,2), nrow =2)
     X <- cbind(1, rep(1:10,10))
     h <- X %*% theta + rnorm(100,0,0.2)
     
     theta_current <- as.matrix(c(0,0), nrow =2)
     theta_new <- as.matrix(c(1,1), nrow =2)
     alpha <- 0.0001
     tolerance <- 0.000001
     m <- length(h)
     
     tX <- t(X)
     t5 <- system.time({
     while(sum(abs(theta_new-theta_current)>tolerance)){
             theta_current <- theta_new
             theta_grad <- tX %*% ((X %*% theta_current) - h)
             theta_new <- theta_current - alpha/m * theta_grad
     }
     })
     
```


```{r problem4, echo=F, warn=F}
#Bootstrap can adjust issues of normality for residuals
#Can also use for noncon var, make sure data independent
#Start by reading in x and y
set.seed(1267)
n <- 200
x <- 1/cbind(1,rt(n,df=1),rt(n,df=1),rt(n,df=1))
beta <- c(1,2,3,0)
y <- x %*% beta + rnorm(100,sd=3)

bootbeta <- matrix(NA,nrow = 10000,ncol = 4)
for(b in 1:10000){
    bootid <- sample(1:200, 200, replace=T)
    bootx <- x[bootid,]
    booty <- y[bootid]

    bootbeta[b,] <- coef(lm(booty~0+bootx)) 
}

CI95beta <- quantile(bootbeta, prob=c(.025, .975))
CI95betalower <- CI95beta[1]
CI95betaupper <- CI95beta[2]

CI95beta

#Check to see if 0 is in interval, then done
```




